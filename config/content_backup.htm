<h1>Stage-1</h1>
<p>Task:請在第一階段設計一機構，並進行分析</p>
<h2>最終結果</h2>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/md3fNab1UXo" width="560"></iframe></p>
<p>檔案:<a href="https://drive.google.com/drive/folders/1q6IpKE3ioOUxaq6NiQQoDIF4QNhAu3IW?usp=sharing">雲端硬碟</a></p>
<h2>問題檢討</h2>
<h3>最佳化設計</h3>
<p>若一個機構在滿足所有應符合的限制底下，且能符合最終運行的目的，此機構則是一個可行的機構。</p>
<p>在可行的情況下，機構並不只有一種形式，因此機構在分析時可考慮到如何簡化?是否影響運動?等等</p>
<p>優質的最佳化設計可使模擬結果更貼近現實，但過多的刪減也會造成反效果。</p>
<p>這次專案若能確實實施最佳化，則模擬產生的問題就能減少!</p>
<h3>模擬的碰撞問題</h3>
<p>CoppeliaSim的模擬中，碰撞是一門大的學問!</p>
<p>藉由零件的分割與組合可改善許多碰撞的產生，而簡化零件也是其中的一大重點。</p>
<p>若模擬時零件簡化得當，模擬結果會更加貼近，但是過度的簡化模型也會造成模擬結果得不準確，</p>
<p>因此該如何簡化、簡化多少、該不該簡化都是需要討論的一大問題。</p>
<p>而且簡化後的模型無法完整顯示當初設計的細節，如果把原零件的外型貼在簡化模型的表面後，將簡化模型隱藏後，整體可達到模擬的效益，又不改變大體外觀。</p>
<p><img alt="" height="249" src="/images/ucHJlTG.gif" width="492"/></p>
<h3>機構模型過於理想</h3>
<p><span></span>此次專案除了機械手臂的操作，一大重點就是套環的傳送!</p>
<p>設計機構時，腦內預想的情況都過於理想，導致實際模擬時錯誤百出。</p>
<p>如間隙問題導致套環掉落、重心配置不妥當等等都是在機構創建階段就須討論的議題，而不是模擬階段再進行處理。</p>
<p>在設計階段就需要考慮進運動學的概念，如此，在符合理論概念的基礎之下，模擬與實際結果差異也會縮小。</p>
<p><img alt="" height="319" src="/images/mdndwTd.gif" width="630"/></p>
<p>                                                                              重心調整後</p>
<p></p>
<h3>時間裕度</h3>
<p>此次專案實行的實際時間約莫兩周左右，原先進度設定是使用一週進行機構的創建，另一週進行模擬。</p>
<p>但是，繪製3D模型時花了過多時間處理，而機構設計又過於理想，最終模擬時進行多次修改，而每次修改後又需重新加入電機、參數設定等，此等多種原因導致必須捨棄原機構，將設計改成履帶傳輸。</p>
<p><img alt="" height="238" src="/images/Inventor_KbZb4t18fg.png" width="474"/></p>
<p>                                                   原模型</p>
<p><img alt="" height="227" src="/images/zzzT9D6.jpeg" width="472"/></p>
<p>                                                用履帶代替</p>
<h2>week2</h2>
<p>構想提出:</p>
<ol>
<li><span>方向:夜市遊戲</span></li>
<li>模擬:coppeliasim</li>
<li>特點:可控制丟出</li>
</ol>
<p>討論結果:</p>
<ol>
<li>夜市套圈圈</li>
<li>藉由機械手臂達成</li>
<li>套環由運送機構送達</li>
</ol>
<p>運送機構參考:<a href="https://www.bilibili.com/video/BV1uJ411c7P2?from=search&amp;seid=729605612778702315">傳送機構</a></p>
<p></p>
<h2>week3</h2>
<p>本週主軸:CoppeliaSim模擬與運送機構創建</p>
<p>整體運用重點:</p>
<ol>
<li>YouBot運用</li>
<li>IK逆運動學</li>
<li>套環機構創建</li>
</ol>
<p>本週問題:</p>
<ol>
<li>YouBot的夾爪並不適合夾取套環</li>
<li>YouBot程式編寫</li>
<li>機構干涉與夾取時的配合</li>
</ol>
<p>問題改善:</p>
<ol>
<li>新夾爪的選用</li>
<li>放棄用角度進行運動控制</li>
<li>使用路徑反向控制運動方式</li>
</ol>
<p>模擬紀錄:</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/nPfChqiGg-A" width="560"></iframe></p>
<h2>week4</h2>
<p>project-1重點總結</p>
<ul>
<li>機器手臂運動</li>
<li>夾爪認識</li>
<li>元件特性</li>
<li>程式碼認知</li>
</ul>
<p>專案檢討</p>
<ul>
<li>未考慮時間裕度</li>
<li>機構模型過於理想</li>
<li>模擬的碰撞問題未解決</li>
<li>未構思最佳化設計</li>
</ul>
<p>總結:</p>
<p>此次專案是使用機械手臂進行套圈圈，在模擬的初步選用是使用youbot進行。</p>
<p>youbot的內建功能可自行條整關節運動與夾爪，並且手臂主關節數較少，故挑選youbot進行初步的機械手臂的解析。在機械手臂的熟悉過程中發現到兩大重要的原理-正向運動學與逆向運動學。</p>
<p>正向運動學是調整關節達到最終預期的運動，而逆向運動學則是給予運動的結果反向轉換成運動。<br/>雖然逆向運動學可直接給予結果來產生運動，在整體上擁有較多調整的彈性，但正向運動學不可取代的則是一步一步的詳細調整所有關節運動的能力，但也正是此種特性造成牽一髮而動全身的局面，因此設計的複雜度上難度較高，修改上也較為麻煩!</p>
<p>此專案在各種層面上，無論是時間或是追求的運動結果都顯示了選用IK逆運動學是較好的選擇!<br/>而運用到的核心重點是藉由創建path，經由虛擬對象dummy進行引導，使機械手臂的夾爪追蹤dummy以進行運動。</p>
<p>以上都只是談到套圈的機械手臂，而專案的另一項重點則是運送套環的機構。</p>
<p>在機構設計上，構思出的虛擬模型過於完美，重心、物件配合等等都過於理想化，導致一切在加入重力、碰撞等因素時需大規模改善，也因此造成時間不足!<br/><br/></p>
<p>模擬上，欠缺最佳化的設計與模型簡化，因而在模擬的進行階段受碰撞的影響導致模擬卡頓，這些重大缺失極大影響到模擬最終的結果。</p>
<p>此外不足之處還有套環運送的時間間隔、機械手臂的運動速度與路徑規劃及夾爪開闔速度跟抓取的難易度，這些種種問題都是互相關聯的，也是最終檢討的一環!</p>
<p>以上諸多問題大多可避免，經由這次專案的缺失將自身經驗分享，也可從其餘組別中互相學習，並統整行為模式，讓下次專案更加有效率!</p>
<h1>Stage-2</h1>
<p>汲取第一階段各組經驗，於期中前完成第二階段成果</p>
<h2>week6</h2>
<p>構想提出:</p>
<ol>
<li><span>方向:球類運動</span></li>
<li>模擬:coppeliasim</li>
<li>可經由機械手臂達成</li>
</ol>
<p>討論結果:</p>
<ol>
<li>棒球打擊模擬</li>
<li>由stage-1延伸</li>
<li>棒球經由機構送達</li>
</ol>
<p></p>
<h2>week7</h2>
<p>本週主軸:CoppeliaSim模擬與運送機構創建</p>
<p>整體運用重點:</p>
<ol>
<li>向本週主軸:CoppeliaSim模擬與運送機構創建</li>
</ol>
<p>整體運用重點:</p>
<ol>
<li>IK逆運動學</li>
<li>正向運動學</li>
<li>送球機構創建</li>
</ol>
<p>本週問題:</p>
<ol>
<li>多軸手臂的運動預測</li>
<li>送球機構創建未果</li>
<li>球受力後的運動路徑預測</li>
</ol>
<p>問題改善:</p>
<ol>
<li>藉由DH法做運動預期</li>
<li>加入運動學運算</li>
</ol>
<h2>week8</h2>
<p>本週主軸:機械手臂程式撰寫與送球機構修改</p>
<p>整體運用重點:</p>
<ol>
<li>Lua語言</li>
</ol>
<p>本週問題:</p>
<ol>
<li>送球機構運動結果未達預期</li>
<li>球到達定點前即掉落</li>
<li>手臂運動路徑不夠近似真實擊球</li>
</ol>
<p>問題改善:</p>
<ol>
<li>擋板修改</li>
<li>修改至接近真人手臂擊球的動作</li>
</ol>
<h2>week9</h2>
<p>project-2重點總結</p>
<ul>
<li>機器手臂運動</li>
<li>運動學</li>
<li>Lua程式認知</li>
<li>送球機構修改</li>
</ul>
<p>專案檢討</p>
<ul>
<li>同步情形略有改善</li>
<li>分工領域較上次精確</li>
<li>預想模型較上次合理</li>
</ul>
<p>總結:</p>
<p>此次專案較stage-1分工更加明確，各領域負責者各司其職，並未因人數增加而導致部分人員偷懶。</p>
<p>在具有stage-1的基礎知識之下，研讀其他文獻時理解也更加快速!</p>
<p></p>
<p>機構預想上較stage-1更加縝密，減少了過於理想化的情況，也因此修改的時間花費更少。</p>
<p>成品:</p>
<h1>Stage-3</h1>
<h2>模型簡化</h2>
<p>coppeliasim的模型並不是我們在繪圖軟體畫得那樣平順，因為導入模型時軟體會將物件做分割，以便進行力學計算，而下列影片將講述有關於為什麼要進行模型簡化的初步概念，內容可能非百分百正確的概念，請諒解</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/H7Ko2wIVNDo" width="560"></iframe></p>
<p></p>
<p></p>
<h2>W16 exam</h2>
<p>關於內容的講解，請至影片連結觀看，onshape與MTB robot在第二個連結有詳細說明，api部分請至官方查詢</p>
<p><strong>onshape</strong></p>
<p><a href="https://cad.onshape.com/documents/b86909090dc534c65a972d39/w/549ba34594ccf43b5b74018b/e/2c0262282146da66963380b4">連結</a></p>
<p><strong>MTB robot取放 說明</strong></p>
<p><a href="https://www.youtube.com/watch?v=dMsrPQLlR9A&amp;ab_channel=%E7%8E%8B%E9%8A%98%E6%A5%AB">連結</a></p>
<p><strong>MTB robot鍵盤範例 說明</strong></p>
<p><a href="https://www.youtube.com/watch?v=LVjSECSZuzk&amp;ab_channel=%E7%8E%8B%E9%8A%98%E6%A5%AB">連結</a></p>
<p><strong>google dirve檔案</strong></p>
<p><a href="https://drive.google.com/drive/u/1/folders/1bE4Pjyf36YRFcDa-dAT9rZsXSTywkF2T">連結</a></p>
<p></p>
<h2>W13~W14</h2>
<h3>翻譯</h3>
<p><span>We saw this simple two-link robot in the previous lecture about forward kinematics.</span></p>
<p>我們之前有在正向運動學的課程中有看到這個簡單的二連桿機械手臂。</p>
<p></p>
<p><span>The tooltip pose of this robot is described simply by two numbers, the coordinates x and y with respect to the world coordinate frame.</span></p>
<p>這個機械手臂的工具提示框是由相對於世界座標的<span>x</span>與<span>y</span>這兩個簡單的數值所</p>
<p></p>
<p><span>So, the problem here is that given x and y, we want to determine the joined angles, q1 and q2.</span></p>
<p>那麼，問題是，給<span>x</span>跟<span>y</span>，我們要去計算<span>joint</span>的角度<span>q1</span>跟<span>q2</span></p>
<p><span> </span></p>
<p><span>The solution that we’re going to follow in this particular section is a geometric one.</span></p>
<p>這種特定情況的問題我們能利用到幾何</p>
<p><span> </span></p>
<p><span>We’re going to start with a simple piece of construction.</span></p>
<p>我們先從一部份簡單的結構開始</p>
<p><span> </span></p>
<p><span>We’re going to overlay the red triangle on top of our robot.</span></p>
<p>我們把這個紅色三角形覆蓋到我們的機械手臂上</p>
<p><span> </span></p>
<p><span>We know that the end point coordinate is x, y, so the vertical height of the triangle is y, the horizontal width is x.</span></p>
<p>我們知道末端坐標是<span>x</span>跟<span>y</span>，三角形的垂直高度為<span>y</span>，水平寬度為<span>x</span>。</p>
<p><span> </span></p>
<p><span>And, using Pythagoras theorem, we can write r squared equals x squared plus y squared.</span></p>
<p>那麼用畢氏定理，我們能把它寫成<span> r</span>²<span> = x </span>²<span>+ y</span>²。</p>
<p></p>
<p><span>So far, so easy.</span></p>
<p>到現在都還算簡單</p>
<p></p>
<p><span>Now, we’ re going to look at this triangle highlighted here in red and we want to determine the angle alpha.</span></p>
<p>那我們現在來看覆蓋在這的紅色三角形，我們要去算出<span>α</span>角</p>
<p><span> </span></p>
<p><span>In order to do that, we need to use the cosine rule.</span></p>
<p>為了算它，我們要用餘弦定理</p>
<p><span> </span></p>
<p><span>And, if you’re a little rusty on the cosine rule, here is a bit of a refresher.</span></p>
<p>如果餘弦定理對你來講有些生疏了，這邊幫你複習一下</p>
<p><span> </span></p>
<p><span>We have an arbitrary triangle.</span></p>
<p>有個任意三角形。</p>
<p><span> </span></p>
<p><span>We don’t have any right angles in it and we’re going to label the length of this edge as A and the angle opposite that edge, we’re going to label as little a.</span></p>
<p>它裡面沒任何直角，我們在這個邊標示上<span>A</span>，然後對角標一個小<span>a</span></p>
<p><span> </span></p>
<p><span>And, we do the same for this edge and this angle, and this edge and this angle.</span></p>
<p>我們同樣把這個邊，這個角，還有那個邊，那個角標示</p>
<p></p>
<p><span>So, all together, the sides are labelled capitals A, B and C, and the angles are labelled little a, little b, and little c.</span></p>
<p>如此一來，邊標<span>A</span>、<span>B</span>、<span>C</span>，角標<span>a</span>、<span>b</span>、<span>c</span></p>
<p><span></span></p>
<p><span>So, the cosine rule is simply this relationship here.</span></p>
<p>所以呢，餘弦定理在這邊就是那麼簡單</p>
<p></p>
<p><span>It’s a bit like Pythagoras’ theorem except for this extra term on the end with the cos a in it.</span></p>
<p>它有點像畢氏定理，只是多了個<span>cos(a)</span></p>
<p><span> </span></p>
<p><span>Now, let’s apply the cosine rule to the particular triangle we looked at a moment ago.</span></p>
<p>現在，我們把餘弦定理套用在剛剛那個三角形</p>
<p></p>
<p><span>It’s pretty straightforward to write down this particular relationship.</span></p>
<p>這個特殊關係可以直接寫下來</p>
<p></p>
<p><span>We can isolate the term cos alpha which gives us the angle alpha that we’re interested in.</span></p>
<p>我們拿出我們想知道的這個<span>cos</span>α</p>
<p><span> </span></p>
<p><span>And, it’s defined in terms of the constant link lengths, A1 and A2 and the position of the end effector, x and y.</span></p>
<p>而且它是用不變的連桿長<span>A1</span>跟<span>A2</span>，和端效器的位置<span>x</span>、<span>y</span>定義的</p>
<p><span>(<span style="color: #ff0000;">*</span></span>特別補充<span>:</span>端效器就是機械手臂末端，用來跟朝遭互動的裝置，像是夾爪就是常見的端效器，把夾爪裝在手臂末端去夾取周遭的東西<span>)</span></p>
<p><span> </span></p>
<p><span>We can write this simple relationship between the angle alpha and q2.</span></p>
<p>我們能夠寫出α和<span>q2</span>之間簡單的關係</p>
<p><span> </span></p>
<p><span>And, we know from the shape of the cosine function that cos of q2 must be equal to negative of cos alpha.</span></p>
<p><span> </span></p>
<p>而且我們用<span>cos</span>函數的圖能知道<span>cos q2</span>必須等於 –<span>cos </span>α。</p>
<p><span>This time, let’s just write an expression for the cosine of the joined angle q2.</span></p>
<p>這次我們來寫一下其<span>joint</span>角度<span>q2</span>的<span>cos</span>表示式</p>
<p></p>
<p><span>Now, we’re going to draw yet another red triangle and we’re going apply some simple trigonometry here.</span></p>
<p>現在，我們再來畫個紅色三角形，而且我們會用到些簡單的三角函數</p>
<p><span> </span></p>
<p><span>If we know q2, then we know this length and this length of the red triangle.</span></p>
<p>如果我們已知<span>q2</span>，就能得知這個長度和這個紅色三角形的長度。</p>
<p><span> </span></p>
<p><span>We can write this relationship for the sine of the joined angle q2.</span></p>
<p>我們來寫一下這個<span>joint</span>角<span>q2</span>的餘弦關係</p>
<p><span> </span></p>
<p><span>Now, we can consider this bigger triangle whose angle is beta and this side length of this triangle is given here in blue.</span></p>
<p>現在我們考慮比較大的這個三角形，它角度是β，邊則用藍色表示</p>
<p><span> </span></p>
<p><span>And, the length of the other side of the triangle is this.</span></p>
<p>而且呢，三角形的另一邊是這樣的</p>
<p><span> </span></p>
<p><span>So, now we can write an expression for the angle beta in terms of these parameters here.</span></p>
<p>所以現在我們能用這些三角形的參數寫出一個表示式</p>
<p><span> </span></p>
<p><span>Going back to the red triangle that we drew earlier, we can establish a relationship between q1 and the angle beta.</span></p>
<p>回到稍早畫的紅色三角形，我們可建立出<span>q1</span>和β間的關係。</p>
<p><span> </span></p>
<p><span>Introduce yet another angle, this one gamma and we can write a relationship between the angle gamma and the tooltip coordinates x and y.</span></p>
<p>再來介紹另一個角度<span>ɣ</span>，我們可寫出<span>ɣ</span>角和工具框座標<span>x</span>和<span>y</span>之間的關係。</p>
<p><span> </span></p>
<h3>Pick and Place</h3>
<p>task:利用機械手臂將球金字塔從A處轉移至B處</p>
<p>*<span style="background-color: #ff6600;">此成品是參照乙班已完成者結果所完成的，非獨立完成</span></p>
<p><a href="https://drive.google.com/drive/folders/10ctV4pFjcA5JmjR5XoIL6UKzBQ2iY8jl?usp=sharing">檔案</a></p>
<p></p>
<h2>task1</h2>
<h3>獲得正確順序(沒嵌入網站)</h3>
<div class="line number1 index0 alt2">
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">with open("123.txt") as fh:
##記得txt要照編輯的檔名
    data = fh.readlines()
for i in range(len(data)):
    data = [j.replace("a40823112",'') for j in data]
    group = data[i].rstrip("\n").split("\t")
    group = [i for i in group if i]
    new_set = list(set(group))
    old_order = sorted(new_set,key=group.index)
    print(old_order)</pre>
</div>
<div class="line number2 index1 alt1"><code class="py comments"></code></div>
<h3>嵌入網站</h3>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">with open("123.txt") as fh:
    data = fh.readlines()
for i in range(len(data)):
    data = [j.replace("a40823112",'') for j in data]
    group = data[i].rstrip("\n").split("\t")
    group = [i for i in group if i]
    new_set = list(set(group))
    old_order = sorted(new_set,key=group.index)
    print('&lt;p&gt;'+'---------'+group[0]+'|&lt;a href="https://'+group[1]+'.github.io/stage3-ag'+group[0][9]+'"&gt;grp web&lt;/a&gt;|&lt;a href="https://github.com/'+group[2]+'/stage3-ag'+group[0][9]+'"&gt;grp repo&lt;/a&gt;&lt;/p&gt;')
    for x in range(1,16,2):
        try:
            print('&lt;p&gt;'+group[x]+'|Web:'+'&lt;a href="https://'+group[x]+'.github.io/cd2021'+'"&gt;'+group[x]+'&lt;/a&gt;'+'|Repo:'+'&lt;a href="https://github.com/'+group[x]+'/cd2021'+'"&gt;'+group[x]+'&lt;/a&gt;&lt;/p&gt;')
        except:
            continue</pre>
<p></p>
<h2>task2</h2>
<p>將stage-1與stage-2用python remote api 操控</p>
<p></p>
<p>以下為成品，改善方面為接球手臂，擊球手臂只有remote api版本有些微調整，所以會跳出參數提醒(因為擊球手臂的速度跟加速度參數過於誇張，所以會導致結果不穩定，誤差值放大!)</p>
<p>(1)此版本是remote api版本，利用IK概念，控制末端座標達成</p>
<p><a href="https://drive.google.com/drive/folders/1jf143S6Ug-NydPkbdXxO_7bxchTvbHmB?usp=sharing">google drive </a></p>
<p>(2)此版本是lua版本，同樣利用IK概念，但是是建立在三軸上做末端dummy移動</p>
<p><a href="https://drive.google.com/drive/folders/1lquV4GU62pKSobDSgHw8QtI-Qqtev0JJ?usp=sharing">google dirve </a></p>
<h2>task3</h2>
<p>OBS部分請看小組網站</p>
<h1>機器人學</h1>
<h2>正向運動學</h2>
<p><img alt="" height="310" src="/images/002.png" width="500"/></p>
<p></p>
<p>上圖為一個多軸的機械手臂簡圖，若要控制此機械臂可藉由控制每個joint的角度，使夾爪(point3)產生紅色線條的路徑。也就是說，利用每個關節的角度控制來達到終端(夾爪)的目標位置。想像現在你面前有個杯子，他在手臂的正45度處，你想拿起這個杯子，你可以手彎45度拿到這個杯子，就是正向運動學的概念。</p>
<p>正向運動學裡，你可以控制每一個關節的角度，所以對於動作掌握上是百分之百的，但是IK只能確保到目標點，不能掌握動作，而正向運動學因為要控制每個角度，所以計算上較為困難，所以各有利弊</p>
<h2>逆向運動學</h2>
<p><img alt="" height="299" src="/images/002.png" width="482"/></p>
<p>上圖為一個多軸機械手臂的簡圖，紅色部分是移動路徑路徑。想像有個杯子，你的左邊20公分、前面15公分出<span>，你想拿起這個杯子，你的腦袋會告訴你，你現在手臂必須彎曲一個角度才能拿到這個杯子</span>，現在，給予夾爪一個坐標(目的地座標)，是否其他關節能自己推敲出座標與角度，此概念即逆向運動學。<br/>逆向運動學方便且快速，可以減少很多計算時間，尤其在三維空間中!但是正如上面所舉的例子，你的手想拿杯子，可以從左邊拿、從上面拿、側邊拿，不管任何一個方式都能到杯子的位置，也就是說，IK的控制沒辦法像順向(正向)運動學一樣精準，想控制每個角度都行，因為角度是從座標逆推出來的，而N種角度都能到這個座標，所以像是些有限空間或是極度精準的控制就需考慮用正向運動學。</p>
<h1>Program</h1>
<p></p>
<p></p>
<h2>基礎Python</h2>
<p>在此將分享於外部所學的python基礎知識</p>
<p>資料來源:<a href="https://www.youtube.com/user/padalab">彭彭的課程</a></p>
<h3>package-example</h3>
<h4>config.json</h4>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">{"name": "new name", "version": "10.0.0"}</pre>
<p></p>
<h4>main</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import geometry.line #import時，要載入完整的名稱(封包.module)
result = geometry.line.dis(1,5,1,5)
print(result)
#載入封包geometry中的line模組，進行兩點距離運算

import geometry.point
result = geometry.point.slope(1,5,1,5)
print(result)
#載入封包geometry中的slope模組，進行斜率運算

import geometry.point as p
result = p.slope(1,5,1,5) #記得as成另一名稱，後面程式呼叫要記得改
print(result)
</pre>
<p></p>
<h4></h4>
<p></p>
<h3>geometry</h3>
<h4>_init_</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">#一個封包必須要有_init_.py(可以是空的)才能判別，否則判定為普通資料夾
#封包就是模組的資料夾</pre>
<p></p>
<h4>line</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def dis(x1,x2,y1,y2):
    return ((x2-x1)**2+(y2-y1)**2)**0.5
</pre>
<p></p>
<h4>point</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def slope(x1,x2,y1,y2):
    return (y2-y1)/(x2-x1)
</pre>
<p></p>
<h3>funtion-args</h3>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">#參數的預設資料
def power(base,exp=1):
    print(base**exp)
power(11,2)
power(11)
#定義函式時，可assign給變數一個初始值

#使用參數名稱對應
def divide(n1,n2):
    print(n1/n2)
divide(10,2)
divide(n2=2,n1=10)
#呼叫時可直接指定變數去assign，若資料有給初始值，且只要變動一個變數時，用指定則很方便

#無限/不定長度 參數資料
def avg(*ns): 
    sum = 0
    for n in ns :
        sum = sum+n
    print(sum/len(ns))
avg(3,5,10)
avg(2,-1,-1,10)
#將def定義式的變數用*處理，表示可以輸入不定的數值，且會用tuple導入(有序)，因為用tuple，所以用for迴圈做處理，將所有資料印出後累加除以資料數
</pre>
<p></p>
<h3>funtion-basic</h3>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def multiply(n1,n2):
    print(n1*n2)
#定義一個函式(只是定義，沒有真正印出，要呼叫才會執行)
multiply(3,4)
#呼叫出已經定義過的函式multiply，執行裡面寫的東西

value=multiply(3,4)
print(value)
#呼叫函式，所以執行m1*n2，而def沒寫return，就會定義value為none(回傳值return是自己定義的，與函式無關!)

def multiply0(n1,n2):
    return n1*n2
value = multiply0(5,2)+multiply0(2,5)
print(value)
#回傳值的號有個好處，就是可在定義的函式以外繼續操作資料(例如結果的相加)

#函式可用來做程式的包裝，要做同件事時，可以不用一直複製貼上，不只可看性佳，速度又快
def caculate(max):
    sum = 0
    for n in range(1,max+1):
        sum += n
    print(sum)
caculate(10)
caculate(20)
#def 一個累加的程式，若有用到則不用再一直打或複製</pre>
<p></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">#while迴圈
i = 1
while i&lt;=10:
    print(i)
    i+=1
#將i assign成1，然後whlie i小於等於10(滿足while條件)之前，迴圈不斷執行

i = 1
sum = 0
while i&lt;=10:
    sum = sum+i
    i += 1
print(sum)
#先assign i與sum(總和)的值，執行while，把sum加上i的值，然後i+1，印出sum，直到while滿足為止(print如果放回圈內會一直印)
#sum(總和)當作一個變數就好，有新的數值就寫進去變數裡面，然後這張紙的數字就是不斷把所有數值加起來

#for迴圈
for x in [1,3,5]:
    print(x)
#給一個x變數，每次就循序的抓一個資料進去執行動作，直到資料抓完了

for x in 'fuckyou':
    print(x)

for x in range(5):
    print(x)
#for x資料，這個字資料是range(5)，同[0,1,2,3,4,]，會印出到5之前的數字(一樣不含5)

for x in range(5,10):
    print(x)
#印出從5開始到9(不含10)

sum = 0
for x in range(1,11):
    sum = sum+x
print(sum)
#定義初始值sum = 0，for x 一個range(1,11)，sum assign成sum加上x，迴圈結束，執行下個程式print</pre>
<p><br/><br/><br/></p>
<h3>loop-basic</h3>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">#while迴圈
i = 1
while i&lt;=10:
    print(i)
    i+=1
#將i assign成1，然後whlie i小於等於10(滿足while條件)之前，迴圈不斷執行

i = 1
sum = 0
while i&lt;=10:
    sum = sum+i
    i += 1
print(sum)
#先assign i與sum(總和)的值，執行while，把sum加上i的值，然後i+1，印出sum，直到while滿足為止(print如果放回圈內會一直印)
#sum(總和)當作一個變數就好，有新的數值就寫進去變數裡面，然後這張紙的數字就是不斷把所有數值加起來

#for迴圈
for x in [1,3,5]:
    print(x)
#給一個x變數，每次就循序的抓一個資料進去執行動作，直到資料抓完了

for x in 'fuckyou':
    print(x)

for x in range(5):
    print(x)
#for x資料，這個字資料是range(5)，同[0,1,2,3,4,]，會印出到5之前的數字(一樣不含5)

for x in range(5,10):
    print(x)
#印出從5開始到9(不含10)

sum = 0
for x in range(1,11):
    sum = sum+x
print(sum)
#定義初始值sum = 0，for x 一個range(1,11)，sum assign成sum加上x，迴圈結束，執行下個程式print</pre>
<p></p>
<h3>loop-control</h3>
<h3>module</h3>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">#用內建模組取得資訊
import sys
print(sys.platform)#取得作業系統資訊
print(sys.maxsize)#取得最大整數值(不限在python裡面)



import sys as s
print(s.platform)
print(s.maxsize)
#可將模組名稱as為另一名稱做呼叫

import sys
sys.path.append("modules")
print("sys.path")
#增加模組路經，使系統能搜尋到(要在呼叫前就新增才行)
#路徑可用相對路徑或絕對路徑

import sys
print(sys.path)
#印出系統路徑(注意系統路徑!避免檔案找不到)
import geometry 
result=geometry.dis(5,10,5,10)
print(result)
#引用gemetry模組，計算兩點距離
result=geometry.slope(5,10,5,10)
print(result)
#引用gemetry模組，計算兩點斜率

</pre>
<p></p>
<h3>number-string</h3>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># 數字運算
x=3+6
print(x)

x=3-6
print(x)

x=3*6
print(x)

x=3/6
print(x)

x=3//6
print(x)
#小數除法
x=3/7
print(x)
#整數除法

x=2**3
print(x)
#表次方
x=2**0.5
print(x)
#用次方做開根號
x=7%3
print(x)
#求餘數
x=2+3
print(x)

x+=1 
print(x)
x-=1 
print(x)
#與C的+= -= *= /=概念都一樣

# 字串運算
s="Hello"
print(s)

s='Hello'
print(s)
#字串用"" 或 ''都可以 ，但要注意內外層邏輯
s="Hell\"o"
print(s)
#\表示跳脫
s="Hello"+"World"
print(s)

s="Hello\nWorld"
print(s)

s="""Hello


World"""
print(s)
#python限定，三個"""可以做直接換行
s="Hello"*3+"World"
print(s)
#字串運算依然照先乘除後加減

# 字串會對內部的字元編號(索引)，0 開始算起
s="Hello"
print(s[0])
print(s[1])
print(s[2])
#印出第n個字元
print(s[1:4])
#從編號1的字元印到編號4的字元
print(s[:4])
#從一開始印到編號四的字元，注意第一個是0開始
print(s[1:])
#從編號1的字元印到最後
x = ("fuck"+'you'+' ')*3
print(x)</pre>
<p></p>
<h3>set-dictionary</h3>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">s = {3,4,5,6}
print(3 in s)
#印出3這個資料，是否在s裡面

s = {3,4,5,6}
print(3 not in s)
#印出3這個資料，是否"不是"在s裡面

s1 = {1,2,3}
s2 = {2,3,4}
s3 = s1&amp;s2 
print(s3)
#印出s1與s2的交集s3

s3 = s1|s2 
print(s3)
#取得s1與s2的聯集，但不會重複取資料(因為聯集的概念)

s3 = s1-s2 
print(s3)
#從s1減掉與s2相同的部分，即差集(注意!s1-s2不等於s2-s1)

s3 = s1^s2 
print(s3)
#反交集，取s1與s2中不重疊部分

s = set("fuckyou")
print(s)
#把set(字串)拆成集合，不過順序不會照原本的(因為集和本來就沒順序)
print("s" in s)
#印出s這個資料是否在s集合中

#字典運算
dic={"fuck":'幹',"you":'你'}
print(dic["fuck"])
#印出字典裡fuck代表什麼

dic["fuck"] = "love"
print(dic["fuck"])
#把字典裡fuck原本的定義更改成love

dic={"fuck":'幹',"you":'你'}
print("fuck" in dic)
#判斷fuck是否在字典裡

dic={"fuck":'幹',"you":'你'}
print("幹" in dic)
#判斷"幹"是否在字典裡，實際上字典裡只有fuck 與 you ，剩下:的東西是定義

del dic["fuck"]
print(dic)
#刪除字典中的fuck

dic={x:x*2 for x in{3,4,5}}
print(dic)
#用列表產生字典，而字典定義看函數決定</pre>
<p></p>
<h3>start</h3>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">print("安安你好")
#print("")內任何語言都可，但要記得括號內的""或''</pre>
<h3>datatype</h3>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># 資料︰程式的基本單位
# 數字
3456 # 整數
3.5 # 浮點數(小數)

# 字串
"測試中文"
"Hello World"
# 布林值
True
False

# 有順序、可動的列表 List
[3,4,5]
["Hello","World"]
# 有順序、不可動的列表 Tuple
(3,4,5)
("Hello","World")

# 集合 Set
{3,4,5}
{"Hello World"}

# 字典 Dictionary
{"apple":"蘋果","data":"資料"}
# 變數︰用來儲存資料的自訂名稱
# 變數名稱=資料
x=3
# print(資料)
print(x)
x=True # 取代舊的資料
print(x)
x="Hello"
print(x)
x={3,5,6} # 集合 Set
print(x)</pre>
<p></p>
<h3>condition</h3>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">if True:
    print('執行')
#若為true 印出執行(注意 : 跟大小寫)
if False:
    print('執行')
#若為false則不印出

if True:
    print('執行')
else :
    print('不執行')
#if-else句型if成立就做，不成立就做else

x=input("打字啦")
#可輸入訊息，字串內可顯示要說明的文字

x=input("打數字")
x=int(x)
if x&gt;100:
    print('大於100')
else :
    print('小於100')
#輸入字串，並且讓x為int(所以輸入非數字則錯誤)，x進入if-else凾式比大小

x=input("打數字")
x=int(x)
if x&gt;200:
    print('大於200')
elif x&gt;100:
    print('介於200~100')
else :
    print('小於100')
#if-elif-else函式，if成立印出，不成立看elif，elif成立則執行，，elif也不成立就執行else

#四則運算
a=input("打第一個數字")
b=input("打第二個數字")
a=int(a)
b=int(b)
output=input('輸入+-*/')
if output == '+':
    print(a+b)
elif output=='-':
    print(a-b)
elif output=='*':
    print(a*b)
elif output=='/':
    print(a/b)
else :
    print("不要亂打")
#輸入a與b再輸入運算子output，若為四則運算印出，若不是則印出else提示字(elif能有好幾個)</pre>
<h3>list-tuple</h3>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># 有序可變動列表 List
grades=[12,60,25,70,90]
#給予一列表list[]，裡面的是資料

print(grades)
print(grades[0])
#印出編號第0個的資料

print(grades[3])
print(grades[1:4])
#印出編號1到3的資料(在1到4的區間，但不含4)


grades=[12,60,25,70,90]
grades[0]=55 
# 把編號0的資料assign成55

print(grades)
grades=[12,60,25,70,90]
grades[1:4]=[] 
# 把編號從1到3的資料(1到4的區間，不含4)變成空的(刪掉)

print(grades)
grades=[12,60,25,70,90]
grades=grades+[12,33]
print(grades)
#grade合成

grades=[12,60,25,70,90] 
length=len(grades)
print(length)
# 取得列表的長度(資料有幾個)，len(列表資料)，

data=[[3,4,5],[6,7,8]]
print(data[0])
#印出編號0的資料(此時編號0是一個garde[3,4,5])

print(data[0][1])
#印出資料編號0中的編號1資料
print(data[0][0:2])
#印出資料編號0中從0~1編號的資料(不含2)
print(data)
data[0][0:2]=[5,5,5]
print(data)
#把資料編號0中編號0~1資料assign成資料{[5,5,5]，然後印出

# 有序不可變動列表 Tuple
data=(3,4,5)
print(data[2])
print(data[0:2])
#用法同list，但資料不可變

data[0] = 5
print(data)
# # 錯誤︰Tuple的資料不可以變動</pre>
<p></p>
<h1>About</h1>
<p>Repository: <a href="https://github.com/mdecourse/cmstemplate">https://github.com/mdecourse/cmstemplate</a></p>
<p>Github Pages: <a href="https://mde.tw/cmstemplate">https://mde.tw/cmstemplate</a></p>
<p>利用 cmstemplate 建立以 CMSiMDE 作為子模組的動態與靜態網站方法為:</p>
<ol>
<li>登入 Github 帳號</li>
<li>將瀏覽器指向 <a href="https://github.com/mdecourse/cmstemplate">https://github.com/mdecourse/cmstemplate</a></li>
<li>利用 <span style="background-color: #00ff00;">Use this template</span> 按鈕建立倉儲</li>
</ol>
<p>clone 帶有 CMSiMDE 的指令:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">git clone --recurse-submodules URL</pre>
<p>上述 URL 即為希望將倉儲資料取下進行改版的 Github 倉儲網路統一資源位置, 也就是 Github 倉儲網址.</p>
<p>每一個以 cmstemplate 為 template 的倉儲, 其根目錄都帶有:</p>
<ol>
<li><span style="background-color: #ffff99;">init.py</span> - 其中的 site_title, ip 與 port 可以讓使用者自行修改, site_title 是網站標題, ip 為動態網站啟動時所使用的網路位址, 可設為內部或外部 IPv4 (IPv6), port 則是動態網站啟動時所佔用的埠號.</li>
<li><span style="background-color: #ffff99;">http-server.py</span> - 執行後會使用內建的 localhost 與 port 8444 伺服 content 子目錄中的 CMSiMDE 靜態網頁.</li>
<li><span style="background-color: #ffff99;">cms.bat</span> - 讓使用者執行動態網站用的批次檔案.</li>
<li><span style="background-color: #ffff99;">acp.bat</span> - 若使用者已經將倉儲設為 ssh 連線, 且提供遠端與近端的認證模式, 則可以在執行此批次指令之後加上提交字串, 即可執行 git add ., git commit -m "提交訊息", 以及 git push 等三個指令.</li>
</ol>
<h1>學期總結</h1>
<h1>CMSiMDE</h1>
<p>CMSiMDE (<a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a>) 是一套以 Python 與 Flask 框架編寫的網際內容管理系統,</p>
<p>使用 CMSiMDE 建議使用者安裝 flask flask_cors bs4 lxml pelican markdown leo 等模組. 其中的 flask flask_cors bs4 lxml pelican markdown為啟動 CMSiMDE 的必要模組, 而 leo 則是 CMSMDE 開發者所使用的大綱管理工具, 可以用於與 CMSiMDE 整合的 Pelican blog 及 Reveal.js 網際簡報編輯之用.</p>
<h2>基本操作</h2>
<p>當使用者利用 cms.bat 啟用動態網站後, 即可利用瀏覽器 <a>https://localhost:9443</a> 在近端維護網站內容, 由於此時動態網站僅在 localhost 啟動, 因此可以使用內建的管理者密碼 "admin" 登入管理網站內容.</p>
<p>假如使用者修改 init.py 中的 ip 或 uwsgi 設定, 讓動態網站在外部 IP 啟動, 則必須自行透過動態網站中的 <span style="background-color: #ffff99;">config</span> 指令修改管理者密碼.</p>
<p>動態網站編輯表單中的 <span style="background-color: #ffff99;">config</span> 除了可更改網站管理者密碼外, 也可以更改網站的頁面內容標題 (外部標題可以透過 init.py 中的 site_title 更改).</p>
<h3>編輯網頁內容</h3>
<p>編輯 CMSiMDE 動態網站中的內容, 可以透過表單中的 <span style="background-color: #ffff99;">Edit All</span> 或 <span style="background-color: #ffff99;">Edit</span> 按鈕進行. <span style="background-color: #ffff99;">Edit</span> 可用於單頁編輯, 操作時先選擇左側的頁面標題, 等系統顯示該頁面內容後, 再點擊上方的 <span style="background-color: #ffff99;">Edit</span> 按鈕即可進入該頁面的編輯模式.</p>
<p><span style="background-color: #ffff99;">Edit All</span> 通常用於單次刪除所有頁面內容或者只保留特定頁面用, 點擊後會將所有頁面內容置於編輯器中.</p>
<h3>上傳與引用檔案</h3>
<p><span style="background-color: #000000; color: #ffffff;">File Upload</span> 可以讓使用者選擇近端多個檔案上傳至動態系統中的 downloads 目錄.</p>
<p>引用使用者上傳的檔案</p>
<p style="padding-left: 30px;"><a href="/downloads/python_book_01.pdf">python_book_01.pdf</a></p>
<h3>上傳與引用圖片</h3>
<p><span style="background-color: #000000; color: #ffffff;">Image Upload</span> 可以讓使用者選擇近端多個檔案上傳至動態系統中的 downloads 目錄.</p>
<p>引用使用者上傳的檔案</p>
<p style="padding-left: 30px;"><img caption="false" class="add_border" height="227" src="/images/nfu_logo_mde.png" width="200"/></p>
<p style="padding-left: 30px;"></p>
<h3>嵌入程式碼</h3>
<p>利用 Insert/Edit code 功能, 可以嵌入各種程式碼:</p>
<pre class="brush:dart;auto-links:false;toolbar:false" contenteditable="false">// 下列 Dart 程式, 利用 Runge Kutta 迭代運算法, 解常微分方程式
// 設 t 為時間, x 則設為物體的位移
// dx / dt = (t - x)/2, 起始值 t0=0, x0=1, 求 t=2 時的 x 值
//
// 已知起始值 t0 與 x0 後, 可以利用下列 rungeKutta 函式, 以
// h 為每步階增量值, 求 dxdt 常微分方程式任一 t 的對應值 x
// 定義函式 rungeKutta, 共有四個輸入變數
rungeKutta(t0, x0, t, h) {
  // 利用步階增量值 h 與 t 的起始及終點值
  // 計算需要迭代的次數 n
  int n = ((t - t0) / h).toInt();
  // 宣告 x 為雙浮點數, 且設為起始值 x0
  double x = x0;
  // 利用已知的 t0, x0, t 終點值與步階增量值 h, 迭代求 x 對應值
  // 索引值 i 將每次增量 1, 從 i=1 執行 for 環圈至 i=n
  for (int i = 1; i &lt;= n; i++) {
    // 將此階段的 t 與 x 值代入 dxdt 函式求下列四個浮點變數值
    double k1 = h * dxdt(t0, x);
    double k2 = h * dxdt(t0 + 0.5 * h, x + 0.5 * k1);
    double k3 = h * dxdt(t0 + 0.5 * h, x + 0.5 * k2);
    double k4 = h * dxdt(t0 + h, x + k3);
    // 利用上述四個變數值求此步階增量後的對應 x 值
    x = x + (1.0 / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4);
    // 每次 for 迴圈執行最後, 準備計算下一個步階增量後的 x 對應值
    // t 起始值配合步階增量值 h, 進行增量
    t0 = t0 + h;
  }
  // 完成 for 迴圈迭代後, 傳回與 t 終點值對應的 x 值
  return x;
}

// 將微分方程式 "dx / dt = (t - x)/2" 定義為 dxdt 函式
dxdt(t, x) {
  return ((t - x) / 2);
}

// 定義 main() 主函式內容, 目的在利用 rungeKutta 函式
// 解常微分方程式
main() {
// Driver method
// num 資料型別可以是整數或雙浮點數
  num t0 = 0;
  num x = 1;
  num t = 2;
  double h = 0.2;
  print('The value of x at t=$t is: ${rungeKutta(t0, x, t, h)}');
}
</pre>
<p></p>
<h3>嵌入影片檔</h3>
<p>直接利用 Source code 功能, 將影片檔案的 iframe 標註放入後存檔:</p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/bZupkkT4T5c" width="560"></iframe></p>
<h3>檢視 STL</h3>
<p>使用 Github 所提供的 STL viewer 嵌入 github.com/mdecourse/cmstemplate main branch 中 downloads 目錄中的 spikeball.stl</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;script src="https://embed.github.com/view/3d/mdecourse/cmstemplate/main/downloads/spikeball.stl"&gt;&lt;/script&gt;</pre>
<p>將上列 script 標註放入頁面 HTML 內容後, 可以檢視 STL 零件檔案.</p>
<p></p>
<p>
<script src="https://embed.github.com/view/3d/mdecourse/cmstemplate/main/downloads/spikeball.stl"></script>
</p>
<p>以 CMSiMDE 內建的 static/viewstl.html 檢視 STL 檔案:</p>
<p>使用 iframe 其 src 指向 STL 檔案的絕對 URL 路徑:</p>
<p>/static/viewstl.html?src=https://mde.tw/cmstemplate/downloads/spikeball.stl</p>
<p>就可以如下檢視 downloads/spikeball.stl</p>
<p><iframe height="400" src="/static/viewstl.html?src=https://mde.tw/cmstemplate/downloads/spikeball.stl" width="600"></iframe></p>
<h2>Gitlab 同步</h2>
<p>利用 git remote add gitlab <a href="https://gitlab.com/user/repository.git">https://gitlab.com/user/repository.git</a> 可以在近端倉儲中的 .git/config 中新增一個名稱為 gitlab, 且與 <a href="https://gitlab.com/user/repository.git">https://gitlab.com/user/repository.git</a> 倉儲對應的設定. 使用者可以將此倉儲改版內容以 git push gitlab 推向 Gitlab.</p>
<p>至於 Gitlab Pages 額外需要下列 .yml 檔案進行轉換設定:</p>
<p>.gitlab-ci.yml</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">pages:
  stage: deploy
  script:
  - mkdir .public
  - cp -r * .public
  - mv .public public
  artifacts:
    paths:
    - public
  only:
  - master
variables:
  GIT_SUBMODULE_STRATEGY: recursive</pre>
<p></p>
<h2>Heroku 部署</h2>
<p>與 Heroku 部署有關資訊請參考: <a href="https://mde.tw/cp2020/content/Heroku.html">https://mde.tw/cp2020/content/Heroku.html</a></p>
<h2>Fossil SCM</h2>
<p>在 Github 之外, 可以同步將各倉儲資料存放至 Gitlab, Heroku (有 500 MB 容量限制) 與 Fossil SCM.</p>
<p>希望整合 Github 與 Fossil SCM 倉儲步驟說明如下:</p>
<p>針對 Github 中已經有 <a href="https://github.com/mdecourse/cmstemplate">https://github.com/mdecourse/cmstemplate</a> 倉儲, 希望同步建 <a href="https://fossil.kmol.info/cmstemplate">https://fossil.kmol.info/cmstemplate</a> 與之內容同步.</p>
<p>登入 fossil.kmol.info 主機, 在 /home/user/repository 目錄中, 以 fossil init cmstemplate.fossil 建立空倉儲. 此時 Fossil SCM 將會列出以登入帳號作為帳號的管理者密碼.</p>
<p>管理者利用 <a href="https://fossil.kmol.info/cmstemplate">https://fossil.kmol.info/cmstemplate</a> 連結, 以 user 登入, 並利用上列管理者密碼進入管理區, 先行透過 Setup/users 變更 user 對應密碼.</p>
<p>回到 Windows 以 <span style="background-color: #ffff99;">fossil clone https://user@fossil.kmol.info/cmstemplate cmstemplate.fossil</span> 取下倉儲資料, 過程中將需要輸入與 user 對應的密碼, 並被詢問是否儲存密碼, 若選擇儲存密碼則隨後的 fossil commit 將回自動提交推送.</p>
<p>接著在近端必須開啟空 cmstemplate.fossil 倉儲, 主要目的是取得 __FOSSIL__, 並且以 git pull 完整拉下位於 <a href="https://github.com/mdecourse/cmstemplate">https://github.com/mdecourse/cmstemplate</a> 中的資料並與空 __FOSSIL__ 進行整合. 其中在 Fossil SCM 端必須將 Setup/Settings 中的 default-csp 設為: <a href="https://fonts.googleapis.com">https://fonts.googleapis.com</a> (讓 CMSiMDE 靜態網頁可以在 Fossil SCM doc 頁面中正常顯示), 且勾選 dotfiles (讓 Fossil SCM 可以儲存 .git 中的版本資料).</p>
<p></p>
<h4>參考資料:</h4>
<p>編譯 Fossil SCM:</p>
<p style="padding-left: 30px;"> <a href="http://project.mde.tw/blog/zai-msys2-huan-jing-bian-yi-fossil-scm.html">http://project.mde.tw/blog/zai-msys2-huan-jing-bian-yi-fossil-scm.html</a></p>
<h1>建立網頁</h1>
<p>由於 CMSiMDE 帶有動態網頁與靜態網頁等兩個部分, 動態網頁執行時需要該伺服器能夠執行 Python 3, 以及 flask flask_cors bs4 lxml pelican markdown 等模組. 而靜態網頁的伺服則只需要 WWW Server 即可.</p>
<p>若使用者在 Github 使用 CMSiMDE 建立網頁, 可以透過 <a href="https://github.com/mdecourse/cmstemplate">https://github.com/mdecourse/cmstemplate</a> template 建立, 步驟與兩種設定方式如下:</p>
<ol>
<li>使用者登入 Github</li>
<li>將瀏覽器連線至 <a href="https://github.com/mdecourse/cmstemplate">https://github.com/mdecourse/cmstemplate</a> 頁面後, 點擊 Use this template 按鈕後, 選擇所要採用的 repository 名稱後, 就可以建立以 CMSiMDE 作為子模組的 Github 倉儲.</li>
<li>假如使用者所選擇的倉儲名稱為: 帳號.github.io, 則 Github 會自動設定該倉儲的 main 分支為 Github Pages 根目錄, 意即一旦 Github Pages 完成轉檔 (提交訊息之後會出現綠勾), 則該倉儲的對應網頁將為: https://帳號.github.io</li>
<li>若使用利用 <a href="https://github.com/mdecourse/cmstemplate">https://github.com/mdecourse/cmstemplate</a> 作為 template 所建立的倉儲名稱並非 帳號.github.io, 則使用者必須自行至該倉儲的 settings/Github Pages 選項中將 main branch 設為 Github Pages 對應的 root 目錄. 之後, Github 將會採用: 帳號.github.io/倉儲名稱 作為與該倉儲對應的 Github Pages 網址.</li>
</ol>
<h1>網站錯誤</h1>
<p>因為 <a href="https://github.com/mdecourse/cmstemplate">https://github.com/mdecourse/cmstemplate</a> 將 CMSiMDE 倉儲作為 submodule, 因此使用者利用 cmstemplate 作為 template 後, 必須使用 git clone --recurse-submodules 取下遠端倉儲.</p>
<p>例如:</p>
<p style="padding-left: 30px;">若使用者的倉儲 URL 為 <a href="https://github.com/mdecourse/cmstemplate">https://github.com/mdecourse/cmstemplate</a></p>
<p style="padding-left: 30px;">則可以在近端利用:</p>
<p style="padding-left: 30px;">git clone --recurse-submodules <a href="https://github.com/mdecourse/cmstemplate.git">https://github.com/mdecourse/cmstemplate.git</a></p>
<p style="padding-left: 30px;">將遠端倉儲資料存入 cmstemplate 目錄中.</p>
<p>目前的 cmstemplate 內建 cms.bat 與 acp.bat 等兩個 batch 檔案, 可以協助使用者直接在倉儲根目錄啟動 CMSiMDE 動態網頁, 以及單一指令式即可完成 git add, git commit 以及 git push, 但是前提是使用者必須設定以 ssh 方式與 Github 倉儲進行驗證.</p>
<p>例如:</p>
<p style="padding-left: 30px;">若使用者已經將倉儲內容 clone 至近端, 且已經帶有 cmsimde 子模組的內容.</p>
<p style="padding-left: 30px;">則可以在近端命令列進入 cmstemplate 倉儲目錄執行:</p>
<p style="padding-left: 30px;">cms.bat</p>
<p style="padding-left: 30px;">開啟動態網頁系統. 並以 <a>https://localhost:9443</a> 開啟.</p>
<p style="padding-left: 30px;">一旦完成動態網頁的編輯, 利用 Generate Pages 可以轉為靜態網站, 且各 html 檔案將位於 content 目錄中.</p>
<p style="padding-left: 30px;">若使用者希望檢查近端靜態網頁的內容, 可以利用 SciTE 開啟倉儲中的 http-server.py, 並利用瀏覽器以 <a href="https://localhost:8444">https://localhost:8444</a> 檢查靜態網頁內容.</p>
<p style="padding-left: 30px;">一旦使用者要將近端倉儲的動態與靜態網頁內容推向 Github, 則必須將倉儲中 .git/config 的 url, 從 https 改為 ssh 的連線格式:</p>
<p style="padding-left: 30px;">例如:</p>
<p style="padding-left: 60px;">原先 .git/config origin 的 url 為 url = <a href="https://github.com/mdecourse/cmstemplate.git,">https://github.com/mdecourse/cmstemplate.git,</a> 則必須改為:</p>
<p style="padding-left: 60px;">url = <a href="mailto:git@github.com:mdecourse/cmstemplate.git">git@github.com:mdecourse/cmstemplate.git</a></p>
<p style="padding-left: 60px;">之後假如使用者要以 "add some files" 字串當作提交說明訊息, 則可以在命令列中的倉儲目錄執行:</p>
<p style="padding-left: 60px;">acp.bat "add some files"</p>
<h2>標題選擇</h2>
<p>由於 CMSiMDE 中的動態網站透過 config/content.htm 的 H1~H3 超文件標註進行分頁, 因此使用者利用 cms.bat 開啟動態網站後, 必須注意各頁面標題文字的選擇:</p>
<ol>
<li><span style="background-color: #ffff99;">頁面標題文字儘量簡短</span> - 頁面標題就有如文章的章節標題, 只要該標題具有該頁面內容的代表性即可, 越簡短越好.</li>
<li><span style="background-color: #ffff99;">頁面標題文字不要使用標點符號</span> - 因為標點符號中的 "/" 會造成頁面擷取時 URL 指令分段上的誤判, 至於標題文字中若有 ":" 則會在動態內容轉靜態內容時, 因 Windows 不允許檔案名稱帶有 ":" 而無法轉檔.</li>
<li><span style="background-color: #ffff99;">頁面標題中不可以有超文件標註</span> - 由於 CMSiMDE 動態網站編輯器採用 GUI 進行, 採用滑鼠標修頁面標題時, 可能無意中將 HTML 標註放入 H1~H3 標題文字中, 如此可能會造成 CMSiMDE 分頁錯誤而無法開啟動態網站. 當使用者要檢查所使用的頁面標題是否帶有 html 標註, 可以透過編輯功能中的 Source Code 檢查.</li>
<li><span style="background-color: #ffff99;">H1 標題數量不可過多</span> - 由於 CMSiMDE 的靜態網站支援手機模式, 當頁面 H1 標題數量超過 10 個之後, 頁面標題可能無法在螢幕上最上方以一列顯示, 而是必須出現在第二行, 結果將會導致頁面展開時的 Javascript 程式產生錯亂, 結果為無法直接以滑鼠點擊進入特定頁面.</li>
</ol>
<p></p>
<p></p>
<h2>靜態網頁 404</h2>
<p>當使用者將近端網頁倉儲資料推向 Github 後, commit 提交訊息之後若沒有出現綠勾, 表示靜態網頁無法轉檔成功, 這時連接靜態網頁時, 將會出現 404, 通常情況下是因為倉儲中 cmsimde 子模組的版次無法與遠端 <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 中的版本對應.</p>
<p>上述靜態網頁出現 404 錯誤訊息的處理方式如下:</p>
<ol>
<li>從 <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 倉儲中複製最新版本的版次號, 以 <a href="https://github.com/mdecourse/cmsimde/commit/1c3aeec1f5d26b421743d2f5ef8bb7d5b99292af">2021/03/03 的版次</a>為例, 版次號為 1c3aeec1f5d26b421743d2f5ef8bb7d5b99292af, 使用者只需要最前面的 7 個字元, 也就是 1c3aeec.</li>
<li>然後在近端倉儲中, 以命令列進入 cmsimde 目錄後執行: <span style="background-color: #ffff99;">git checkout 1c3aeec</span></li>
<li>接著退回倉儲目錄, 以 git add, git commit 及 git push 將倉儲改版內容推向 Github 後應該就可以將倉儲正確轉為靜態網站內容.</li>
</ol>
<h2>動態網站錯誤</h2>
<p>CMSiMDE 動態網站經常出現的錯誤是無法對 config/content.htm 分頁, 這時可以利用 SCiTE 編輯 content.htm, 找尋是否 H1~H3 標註中是否帶有特殊符號, 如 "/" 或 ":" 等.</p>
<h2>出現ValueError</h2>
<p>當網站出現ValueError可能是因為generate pages時發生錯誤(如網頁轉換至一半，隨身碟拔除、跳掉)，所以在config下的html無法正確轉換出網頁，因此content.html會是空的(可打開編輯器做確認)，若此時近端的config有備份的html，可在確認版次與內容無誤後直接修復，但記得名稱是content.htm，不是content_backup.html(備份的html)，若備份的html內容有誤，則需從遠端倉儲抓上個版次的!</p>
<h1>延伸開發</h1>
<p>為了建立 responsive site:</p>
<p>靜態網頁:</p>
<p style="padding-left: 30px;">Javascript 程式庫:</p>
<p style="padding-left: 60px;"><a href="https://getbootstrap.com/">https://getbootstrap.com/</a></p>
<p>動態系統:</p>
<p style="padding-left: 30px;">Javascript editor</p>
<p style="padding-left: 60px;">TinyMCE: <a href="https://www.tiny.cloud/">https://www.tiny.cloud/</a></p>
<p style="padding-left: 30px;">Syntax highlighter: <a href="https://prismjs.com/">https://prismjs.com/</a></p>
<p style="padding-left: 30px;">Ajax bit by bit file uploader:</p>
<p style="padding-left: 30px;">Flask</p>
<p style="padding-left: 30px;">Flask_cors</p>
<p style="padding-left: 30px;">bs4</p>
<p style="padding-left: 30px;">lxml</p>
<p style="padding-left: 30px;">markdown</p>
<p></p>